{"version":3,"file":"110.autumnplot-gl.js","mappings":"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","sources":["webpack://apgl/webpack/universalModuleDefinition","webpack://apgl/./src/utils.ts","webpack://apgl/./node_modules/comlink/dist/esm/comlink.mjs","webpack://apgl/./src/Map.ts","webpack://apgl/./src/PlotLayer.worker.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"apgl\"] = factory();\n\telse\n\t\troot[\"apgl\"] = factory();\n})(this, () => {\nreturn ","\nfunction getMinZoom(jlat: number, ilon: number, thin_fac_base: number) {\n    const zoom_base = 1;\n\n    let zoom = zoom_base;\n    let thin_fac = thin_fac_base;\n\n    while (((jlat % thin_fac) != 0) || ((ilon % thin_fac) != 0)) {\n        zoom += 1;\n        thin_fac /= 2;\n    }\n\n    return zoom;\n}\n\nfunction* zip(...args: any[]) {\n\tconst iterators = args.map(x => x[Symbol.iterator]());\n\twhile (true) {\n\t\tconst current = iterators.map(x => x.next());\n\t\tif (current.some(x => x.done)) {\n\t\t\tbreak;\n\t\t}\n\t\tyield current.map(x => x.value);\n\t}\n}\n\nfunction getOS() {\n    const userAgent = window.navigator.userAgent,\n        platform = window.navigator.platform,\n        macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'],\n        windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'],\n        iosPlatforms = ['iPhone', 'iPad', 'iPod'];\n    let os = null;\n\n    if (macosPlatforms.indexOf(platform) !== -1 && navigator.maxTouchPoints <= 1) {\n        os = 'Mac OS';\n    } \n    else if (iosPlatforms.indexOf(platform) !== -1 || (macosPlatforms.indexOf(platform) !== -1 && navigator.maxTouchPoints > 1)) { \n        os = 'iOS';\n    } \n    else if (windowsPlatforms.indexOf(platform) !== -1) {\n        os = 'Windows';\n    } \n    else if (/Android/.test(userAgent)) {\n        os = 'Android';\n    } \n    else if (/Linux/.test(platform)) {\n        os = 'Linux';\n    }\n\n    return os;\n}\n\nclass Cache<A extends unknown[], R> {\n    private cached_values: Record<string, R>;\n    private readonly compute_value: (...args: A) => R;\n    private readonly make_key: (...args: A) => string;\n\n    constructor(compute_value: (...args: A) => R, make_key?: (...args: A) => string) {\n        this.cached_values = {};\n        this.compute_value = compute_value;\n        this.make_key = make_key === undefined ? (...args: A) => JSON.stringify(args) : make_key;\n    }\n\n    public getValue(...args: A) {\n        const key = this.make_key(...args);\n\n        if (!(key in this.cached_values)) {\n            this.cached_values[key] = this.compute_value(...args);\n        }\n\n        return this.cached_values[key];\n    }\n}\n\n\nfunction normalizeOptions<Type extends Record<string, any>>(opts: Type | undefined, defaults: Required<Type>) {\n    const ret = {...defaults} as Required<Type>;\n\n    if (opts !== undefined) {\n        Object.entries(opts).forEach(([k, v]: [keyof Type, any]) => {\n            ret[k] = v;\n        });\n    }\n\n    return ret;\n}\n\nexport {zip, getMinZoom, getOS, Cache, normalizeOptions};\n","/**\r\n * Copyright 2019 Google Inc. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst proxyMarker = Symbol(\"Comlink.proxy\");\r\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\r\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\r\nconst throwMarker = Symbol(\"Comlink.thrown\");\r\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\r\n/**\r\n * Internal transfer handle to handle objects marked to proxy.\r\n */\r\nconst proxyTransferHandler = {\r\n    canHandle: (val) => isObject(val) && val[proxyMarker],\r\n    serialize(obj) {\r\n        const { port1, port2 } = new MessageChannel();\r\n        expose(obj, port1);\r\n        return [port2, [port2]];\r\n    },\r\n    deserialize(port) {\r\n        port.start();\r\n        return wrap(port);\r\n    },\r\n};\r\n/**\r\n * Internal transfer handler to handle thrown exceptions.\r\n */\r\nconst throwTransferHandler = {\r\n    canHandle: (value) => isObject(value) && throwMarker in value,\r\n    serialize({ value }) {\r\n        let serialized;\r\n        if (value instanceof Error) {\r\n            serialized = {\r\n                isError: true,\r\n                value: {\r\n                    message: value.message,\r\n                    name: value.name,\r\n                    stack: value.stack,\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            serialized = { isError: false, value };\r\n        }\r\n        return [serialized, []];\r\n    },\r\n    deserialize(serialized) {\r\n        if (serialized.isError) {\r\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\r\n        }\r\n        throw serialized.value;\r\n    },\r\n};\r\n/**\r\n * Allows customizing the serialization of certain values.\r\n */\r\nconst transferHandlers = new Map([\r\n    [\"proxy\", proxyTransferHandler],\r\n    [\"throw\", throwTransferHandler],\r\n]);\r\nfunction expose(obj, ep = self) {\r\n    ep.addEventListener(\"message\", function callback(ev) {\r\n        if (!ev || !ev.data) {\r\n            return;\r\n        }\r\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\r\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\r\n        let returnValue;\r\n        try {\r\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\r\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\r\n            switch (type) {\r\n                case \"GET\" /* GET */:\r\n                    {\r\n                        returnValue = rawValue;\r\n                    }\r\n                    break;\r\n                case \"SET\" /* SET */:\r\n                    {\r\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\r\n                        returnValue = true;\r\n                    }\r\n                    break;\r\n                case \"APPLY\" /* APPLY */:\r\n                    {\r\n                        returnValue = rawValue.apply(parent, argumentList);\r\n                    }\r\n                    break;\r\n                case \"CONSTRUCT\" /* CONSTRUCT */:\r\n                    {\r\n                        const value = new rawValue(...argumentList);\r\n                        returnValue = proxy(value);\r\n                    }\r\n                    break;\r\n                case \"ENDPOINT\" /* ENDPOINT */:\r\n                    {\r\n                        const { port1, port2 } = new MessageChannel();\r\n                        expose(obj, port2);\r\n                        returnValue = transfer(port1, [port1]);\r\n                    }\r\n                    break;\r\n                case \"RELEASE\" /* RELEASE */:\r\n                    {\r\n                        returnValue = undefined;\r\n                    }\r\n                    break;\r\n                default:\r\n                    return;\r\n            }\r\n        }\r\n        catch (value) {\r\n            returnValue = { value, [throwMarker]: 0 };\r\n        }\r\n        Promise.resolve(returnValue)\r\n            .catch((value) => {\r\n            return { value, [throwMarker]: 0 };\r\n        })\r\n            .then((returnValue) => {\r\n            const [wireValue, transferables] = toWireValue(returnValue);\r\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\r\n            if (type === \"RELEASE\" /* RELEASE */) {\r\n                // detach and deactive after sending release response above.\r\n                ep.removeEventListener(\"message\", callback);\r\n                closeEndPoint(ep);\r\n            }\r\n        });\r\n    });\r\n    if (ep.start) {\r\n        ep.start();\r\n    }\r\n}\r\nfunction isMessagePort(endpoint) {\r\n    return endpoint.constructor.name === \"MessagePort\";\r\n}\r\nfunction closeEndPoint(endpoint) {\r\n    if (isMessagePort(endpoint))\r\n        endpoint.close();\r\n}\r\nfunction wrap(ep, target) {\r\n    return createProxy(ep, [], target);\r\n}\r\nfunction throwIfProxyReleased(isReleased) {\r\n    if (isReleased) {\r\n        throw new Error(\"Proxy has been released and is not useable\");\r\n    }\r\n}\r\nfunction createProxy(ep, path = [], target = function () { }) {\r\n    let isProxyReleased = false;\r\n    const proxy = new Proxy(target, {\r\n        get(_target, prop) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            if (prop === releaseProxy) {\r\n                return () => {\r\n                    return requestResponseMessage(ep, {\r\n                        type: \"RELEASE\" /* RELEASE */,\r\n                        path: path.map((p) => p.toString()),\r\n                    }).then(() => {\r\n                        closeEndPoint(ep);\r\n                        isProxyReleased = true;\r\n                    });\r\n                };\r\n            }\r\n            if (prop === \"then\") {\r\n                if (path.length === 0) {\r\n                    return { then: () => proxy };\r\n                }\r\n                const r = requestResponseMessage(ep, {\r\n                    type: \"GET\" /* GET */,\r\n                    path: path.map((p) => p.toString()),\r\n                }).then(fromWireValue);\r\n                return r.then.bind(r);\r\n            }\r\n            return createProxy(ep, [...path, prop]);\r\n        },\r\n        set(_target, prop, rawValue) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\r\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\r\n            const [value, transferables] = toWireValue(rawValue);\r\n            return requestResponseMessage(ep, {\r\n                type: \"SET\" /* SET */,\r\n                path: [...path, prop].map((p) => p.toString()),\r\n                value,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        apply(_target, _thisArg, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const last = path[path.length - 1];\r\n            if (last === createEndpoint) {\r\n                return requestResponseMessage(ep, {\r\n                    type: \"ENDPOINT\" /* ENDPOINT */,\r\n                }).then(fromWireValue);\r\n            }\r\n            // We just pretend that `bind()` didn’t happen.\r\n            if (last === \"bind\") {\r\n                return createProxy(ep, path.slice(0, -1));\r\n            }\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: \"APPLY\" /* APPLY */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        construct(_target, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: \"CONSTRUCT\" /* CONSTRUCT */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n    });\r\n    return proxy;\r\n}\r\nfunction myFlat(arr) {\r\n    return Array.prototype.concat.apply([], arr);\r\n}\r\nfunction processArguments(argumentList) {\r\n    const processed = argumentList.map(toWireValue);\r\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\r\n}\r\nconst transferCache = new WeakMap();\r\nfunction transfer(obj, transfers) {\r\n    transferCache.set(obj, transfers);\r\n    return obj;\r\n}\r\nfunction proxy(obj) {\r\n    return Object.assign(obj, { [proxyMarker]: true });\r\n}\r\nfunction windowEndpoint(w, context = self, targetOrigin = \"*\") {\r\n    return {\r\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\r\n        addEventListener: context.addEventListener.bind(context),\r\n        removeEventListener: context.removeEventListener.bind(context),\r\n    };\r\n}\r\nfunction toWireValue(value) {\r\n    for (const [name, handler] of transferHandlers) {\r\n        if (handler.canHandle(value)) {\r\n            const [serializedValue, transferables] = handler.serialize(value);\r\n            return [\r\n                {\r\n                    type: \"HANDLER\" /* HANDLER */,\r\n                    name,\r\n                    value: serializedValue,\r\n                },\r\n                transferables,\r\n            ];\r\n        }\r\n    }\r\n    return [\r\n        {\r\n            type: \"RAW\" /* RAW */,\r\n            value,\r\n        },\r\n        transferCache.get(value) || [],\r\n    ];\r\n}\r\nfunction fromWireValue(value) {\r\n    switch (value.type) {\r\n        case \"HANDLER\" /* HANDLER */:\r\n            return transferHandlers.get(value.name).deserialize(value.value);\r\n        case \"RAW\" /* RAW */:\r\n            return value.value;\r\n    }\r\n}\r\nfunction requestResponseMessage(ep, msg, transfers) {\r\n    return new Promise((resolve) => {\r\n        const id = generateUUID();\r\n        ep.addEventListener(\"message\", function l(ev) {\r\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\r\n                return;\r\n            }\r\n            ep.removeEventListener(\"message\", l);\r\n            resolve(ev.data);\r\n        });\r\n        if (ep.start) {\r\n            ep.start();\r\n        }\r\n        ep.postMessage(Object.assign({ id }, msg), transfers);\r\n    });\r\n}\r\nfunction generateUUID() {\r\n    return new Array(4)\r\n        .fill(0)\r\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\r\n        .join(\"-\");\r\n}\n\nexport { createEndpoint, expose, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","\n\n// Stub in required method and property types for the mapping library. God help me if these start to diverge between Mapbox and MapLibre.\ntype StyleSpecification = {\n    glyphs?: string;\n}\n\ntype MapLikeType = {\n    triggerRepaint: () => void;\n    getCanvas: () => HTMLCanvasElement;\n    getStyle: () => StyleSpecification;\n\n    getZoom: () => number;\n    getMaxZoom: () => number;\n    getBearing: () => number;\n    getPitch: () => number;\n};\n\ninterface LambertConformalConicParameters {\n    lon_0: number,\n    lat_0: number,\n    lat_std: [number, number] | number;\n}\n\nfunction lambertConformalConic(params: LambertConformalConicParameters) {\n    // Formulas from https://pubs.usgs.gov/pp/1395/report.pdf\n\n    const compute_t = (lat: number) => {\n        const sin_lat = Math.sin(lat);\n        return Math.tan(Math.PI / 4 - lat / 2) * Math.pow((1 + eccen * sin_lat) / (1 - eccen * sin_lat), eccen / 2);\n    };\n    const compute_m = (lat: number) => {\n        const sin_lat = Math.sin(lat);\n        return Math.cos(lat) / Math.sqrt(1 - eccen * eccen * sin_lat * sin_lat);\n    }\n\n    // WGS 84 spheroid\n    const semimajor = 6378137.0;\n    const semiminor = 6356752.314245;\n    const eccen = Math.sqrt(1 - (semiminor * semiminor) / (semimajor * semimajor));\n    const radians = Math.PI / 180;\n\n    let {lon_0, lat_0, lat_std} = params;\n    lat_std = Array.isArray(lat_std) && lat_std[0] == lat_std[1] ? lat_std[0] : lat_std;\n\n    lon_0 *= radians;\n    lat_0 *= radians;\n\n    let F: number, n: number;\n    const t_0 = compute_t(lat_0);\n\n    if (Array.isArray(lat_std)) {\n        let [lat_1, lat_2] = lat_std;\n        lat_1 *= radians;\n        lat_2 *= radians;\n\n        const t_1 = compute_t(lat_1);\n        const t_2 = compute_t(lat_2);\n        const m_1 = compute_m(lat_1);\n        const m_2 = compute_m(lat_2);\n\n        n = Math.log(m_1 / m_2) / Math.log(t_1 / t_2);\n        F = m_1 / (n * Math.pow(t_1, n));\n    }\n    else {\n        let lat_1 = lat_std;\n        lat_1 *= radians;\n\n        const t_1 = compute_t(lat_1);\n        const m_1 = compute_m(lat_1);\n        n = Math.sin(lat_1);\n        F = m_1 / (n * Math.pow(t_1, n));\n    }\n\n    const rho_0 = semimajor * F * Math.pow(t_0, n);\n\n    const compute_lcc = (lon: number, lat: number) : [number, number] => {\n        lon *= radians;\n        lat *= radians;\n\n        const t = compute_t(lat);\n        const rho = semimajor * F * Math.pow(t, n);\n        const theta = n * (lon - lon_0);\n        const x = rho * Math.sin(theta);\n        const y = rho_0 - rho * Math.cos(theta);\n\n        return [x, y];\n    }\n\n    const eccen2 = eccen * eccen;\n    const eccen4 = eccen2 * eccen2;\n    const eccen6 = eccen4 * eccen2;\n    const eccen8 = eccen6 * eccen2;\n\n/*\n    const A = eccen2 / 2 + 5 * eccen4 / 24 + eccen6 / 12 + 13 * eccen8 / 360;\n    const B = 7 * eccen4 / 48 + 29 * eccen6 / 240 + 811 * eccen8 / 11520;\n    const C = 7 * eccen6 / 120 + 81 * eccen8 / 1120;\n    const D = 4279 * eccen8 / 161280;\n    const Ap = A - C;\n    const Bp = 2 * B - 4 * D;\n    const Cp = 4 * C;\n    const Dp = 8 * D;\n*/\n\n    const Ap = eccen2 / 2 + 5 * eccen4 / 24 + 3 * eccen6 / 120 - 73 * eccen8 / 2016;\n    const Bp = 7 * eccen4 / 24 + 29 * eccen6 / 120 + 233 * eccen8 / 6720;\n    const Cp = 7 * eccen6 / 30 + 81 * eccen8 / 280;\n    const Dp = 4729 * eccen8 / 20160;\n\n    const compute_lcc_inverse = (x: number, y: number) : [number, number] => {\n        const theta = Math.atan2(x, rho_0 - y); // These arguments are backwards from what I'd expect ...\n        const lon = theta / n + lon_0;\n        const rho = Math.hypot(x, rho_0 - y) * Math.sign(n);\n        const t = Math.pow(rho / (semimajor * F), 1 / n);\n\n        const chi = Math.PI / 2 - 2 * Math.atan(t);\n        const sin_2chi = Math.sin(2 * chi);\n        const cos_2chi = Math.cos(2 * chi);\n\n        const lat = chi + sin_2chi * (Ap + cos_2chi * (Bp + cos_2chi * (Cp + Dp * cos_2chi)));\n\n        return [lon / radians, lat / radians];\n    }\n\n    return (a: number, b: number, opts?: {inverse: boolean}) : [number, number] => {\n        opts = opts === undefined ? {inverse: false} : opts;\n        return opts.inverse ? compute_lcc_inverse(a, b) : compute_lcc(a, b);\n    }\n}\n\ninterface RotateSphereParams {\n    np_lon: number,\n    np_lat: number,\n    lon_shift: number,\n}\n\nfunction rotateSphere(params: RotateSphereParams) {\n    const radians = Math.PI / 180;\n    const np_lat = params.np_lat * radians;\n    const np_lon = params.np_lon * radians;\n    const lon_shift = params.lon_shift * radians;\n\n    const sin_np_lat = Math.sin(np_lat);\n    const cos_np_lat = Math.cos(np_lat);\n\n    const compute_rotation = (lon: number, lat: number) : [number, number] => {\n        lon *= radians;\n        lat *= radians;\n\n        const sin_lat = Math.sin(lat);\n        const cos_lat = Math.cos(lat);\n        const sin_lon_diff = Math.sin(lon - lon_shift);\n        const cos_lon_diff = Math.cos(lon - lon_shift);\n\n        const lat_p = Math.asin(sin_np_lat * sin_lat - cos_np_lat * cos_lat * cos_lon_diff);\n        let lon_p = np_lon + Math.atan2((cos_lat * sin_lon_diff), (sin_np_lat * cos_lat * cos_lon_diff + cos_np_lat * sin_lat));\n\n        if (lon_p > Math.PI) lon_p -= 2 * Math.PI;\n\n        return [lon_p / radians, lat_p / radians];\n    }\n\n    const compute_rotation_inverse = (lon_p: number, lat_p: number) : [number, number] => {\n        lon_p *= radians;\n        lat_p *= radians;\n\n        const sin_lat_p = Math.sin(lat_p);\n        const cos_lat_p = Math.cos(lat_p);\n        const sin_lon_p_diff = Math.sin(lon_p - np_lon);\n        const cos_lon_p_diff = Math.cos(lon_p - np_lon);\n\n        const lat = Math.asin(sin_np_lat * sin_lat_p + cos_np_lat * cos_lat_p * cos_lon_p_diff);\n        let lon = lon_shift + Math.atan2((cos_lat_p * sin_lon_p_diff), (sin_np_lat * cos_lat_p * cos_lon_p_diff - cos_np_lat * sin_lat_p));\n\n        if (lon_p > Math.PI) lon_p -= 2 * Math.PI;\n\n        return [lon / radians, lat / radians];\n    }\n\n    return (a: number, b: number, opts?: {inverse: boolean}) => {\n        opts = opts === undefined ? {inverse: false} : opts;\n        return opts.inverse ? compute_rotation_inverse(a, b) : compute_rotation(a, b);\n    }\n}\n\nfunction mercatorXfromLng(lng: number) {\n    return (180 + lng) / 360;\n}\n\nfunction lngFromMercatorX(x: number) {\n    return 360 * x - 180;\n}\n\nfunction mercatorYfromLat(lat: number) {\n    const sin_lat = Math.sin(lat * Math.PI / 180);\n    const y = (180 - (90 / Math.PI * Math.log((1 + sin_lat) / (1 - sin_lat)))) / 360;\n    return Math.min(2, Math.max(-2, y));\n}\n\nfunction latFromMercatorY(y: number) {\n    return Math.atan(Math.sinh((180 - y * 360) * Math.PI / 180)) * 180 / Math.PI;\n}\n\n/**\n * A `LngLat` object represents a given longitude and latitude coordinate, measured in degrees.\n * These coordinates are based on the [WGS84 (EPSG:4326) standard](https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84).\n *\n * MapLibre GL uses longitude, latitude coordinate order (as opposed to latitude, longitude) to match the\n * [GeoJSON specification](https://tools.ietf.org/html/rfc7946).\n *\n * @param {number} lng Longitude, measured in degrees.\n * @param {number} lat Latitude, measured in degrees.\n * @example\n * var ll = new LngLat(-123.9749, 40.7736);\n * ll.lng; // = -123.9749\n */\n class LngLat {\n    public lng: number;\n    public lat: number;\n\n    constructor(lng: number, lat: number) {\n        if (isNaN(lng) || isNaN(lat)) {\n            throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);\n        }\n        this.lng = +lng;\n        this.lat = +lat;\n        if (this.lat > 90 || this.lat < -90) {\n            throw new Error('Invalid LngLat latitude value: must be between -90 and 90');\n        }\n    }\n\n    public toMercatorCoord() {\n        return {x: mercatorXfromLng(this.lng), y: mercatorYfromLat(this.lat)};\n    }\n\n    public static fromMercatorCoord(x: number, y: number) {\n        return new LngLat(lngFromMercatorX(x), latFromMercatorY(y));\n    }\n}\n\nexport {LngLat, lambertConformalConic, rotateSphere};\nexport type {MapLikeType};","\nimport { getMinZoom } from \"./utils\";\nimport { LineData, Polyline } from \"./AutumnTypes\";\n\nimport * as Comlink from 'comlink';\nimport { LngLat } from \"./Map\";\n\nfunction makeBBElements(field_lats: Float32Array, field_lons: Float32Array, field_ni: number, field_nj: number,\n    thin_fac_base: number, max_zoom: number) {\n        \n    const n_pts_per_poly = 6;\n    const n_coords_per_pt_pts = 3;\n    const n_coords_per_pt_tc = 2;\n\n    const n_density_tiers = Math.log2(thin_fac_base);\n    const n_inaccessible_tiers = Math.max(n_density_tiers + 1 - max_zoom, 0);\n    const trim_inaccessible = Math.pow(2, n_inaccessible_tiers);\n\n    const field_ni_access = Math.floor((field_ni - 1) / trim_inaccessible) + 1;\n    const field_nj_access = Math.floor((field_nj - 1) / trim_inaccessible) + 1;\n\n    const n_elems_pts = field_ni_access * field_nj_access * n_pts_per_poly * n_coords_per_pt_pts;\n    const n_elems_tc = field_ni_access * field_nj_access * n_pts_per_poly * n_coords_per_pt_tc;\n\n    let pts = new Float32Array(n_elems_pts);\n    let tex_coords = new Float32Array(n_elems_tc);\n\n    let istart_pts = 0;\n    let istart_tc = 0;\n\n    for (let ilat = 0; ilat < field_nj; ilat++) {\n        for (let ilon = 0; ilon < field_ni; ilon++) {\n            const idx = ilat * field_ni + ilon;\n            const lat = field_lats[idx];\n            const lon = field_lons[idx];\n\n            const zoom = getMinZoom(ilat, ilon, thin_fac_base);\n\n            if (zoom > max_zoom) continue;\n\n            const pt_ll = new LngLat(lon, lat).toMercatorCoord();\n\n            // These contain a degenerate triangle on either end to imitate primitive restarting\n            //  (see https://groups.google.com/g/webgl-dev-list/c/KLfiwj4jax0/m/cKiezrhRz8MJ?pli=1)\n            for (let icrnr = 0; icrnr < n_pts_per_poly; icrnr++) {\n                const actual_icrnr = Math.max(0, Math.min(icrnr - 1, 3));\n\n                pts[istart_pts + icrnr * n_coords_per_pt_pts + 0] = pt_ll.x; \n                pts[istart_pts + icrnr * n_coords_per_pt_pts + 1] = pt_ll.y; \n                pts[istart_pts + icrnr * n_coords_per_pt_pts + 2] = zoom * 4 + actual_icrnr;\n\n                tex_coords[istart_tc + icrnr * n_coords_per_pt_tc + 0] = ilon / (field_ni - 1);\n                tex_coords[istart_tc + icrnr * n_coords_per_pt_tc + 1] = ilat / (field_nj - 1);\n            }\n\n            istart_pts += (n_pts_per_poly * n_coords_per_pt_pts);\n            istart_tc += (n_pts_per_poly * n_coords_per_pt_tc);\n        }\n    }\n\n    return {'pts': pts, 'tex_coords': tex_coords};\n}\n\nfunction makeDomainVerticesAndTexCoords(field_lats: Float32Array, field_lons: Float32Array, field_ni: number, field_nj: number, texcoord_margin_r: number, texcoord_margin_s: number) {\n    const verts = new Float32Array(2 * 2 * (field_ni - 1) * (field_nj + 1)).fill(0);\n    const tex_coords = new Float32Array(2 * 2 * (field_ni - 1) * (field_nj + 1)).fill(0);\n    const grid_cell_size = new Float32Array(1 * 2 * (field_ni - 1) * (field_nj + 1)).fill(0);\n\n    let ivert = 0\n    let itexcoord = 0;\n\n    for (let i = 0; i < field_ni - 1; i++) {\n        for (let j = 0; j < field_nj; j++) {\n            const idx = i + j * field_ni;\n\n            const pt = new LngLat(field_lons[idx], field_lats[idx]).toMercatorCoord();\n            const pt_ip1 = new LngLat(field_lons[idx + 1], field_lats[idx + 1]).toMercatorCoord();\n\n            const r = i / (field_ni - 1) * (1 - 2 * texcoord_margin_r) + texcoord_margin_r;\n            const rp1 = (i + 1) / (field_ni - 1) * (1 - 2 * texcoord_margin_r) + texcoord_margin_r;\n            const s = j / (field_nj - 1) * (1 - 2 * texcoord_margin_s) + texcoord_margin_s;\n\n            if (j == 0) {\n                verts[ivert] = pt.x; verts[ivert + 1] = pt.y;\n                ivert += 2\n\n                tex_coords[itexcoord] = r; tex_coords[itexcoord + 1] = s;\n                itexcoord += 2;\n            }\n\n            verts[ivert    ] = pt.x;     verts[ivert + 1] = pt.y;\n            verts[ivert + 2] = pt_ip1.x; verts[ivert + 3] = pt_ip1.y;\n            ivert += 4;\n\n            tex_coords[itexcoord    ] = r; tex_coords[itexcoord + 1] = s;\n            tex_coords[itexcoord + 2] = rp1; tex_coords[itexcoord + 3] = s;\n            itexcoord += 4;\n\n            if (j == field_nj - 1) {\n                verts[ivert] = pt_ip1.x; verts[ivert + 1] = pt_ip1.y;\n                ivert += 2;\n\n                tex_coords[itexcoord] = rp1; tex_coords[itexcoord + 1] = s;\n                itexcoord += 2;\n            }\n        }\n    }\n\n    let igcs = 0;\n    for (let i = 0; i < field_ni - 1; i++) {\n        for (let j = 0; j < field_nj - 1; j++) {\n            const ivert = j == 0 ? 2 * (igcs + 1) : 2 * igcs;\n            const x_ll = verts[ivert],     y_ll = verts[ivert + 1],\n                  x_lr = verts[ivert + 2], y_lr = verts[ivert + 3],\n                  x_ul = verts[ivert + 4], y_ul = verts[ivert + 5],\n                  x_ur = verts[ivert + 6], y_ur = verts[ivert + 7];\n\n            const area = 0.5 * Math.abs(x_ll * (y_lr - y_ul) + x_lr * (y_ul - y_ll) + x_ul * (y_ll - y_lr) + \n                                        x_ur * (y_ul - y_lr) + x_ul * (y_lr - y_ur) + x_lr * (y_ur - y_ul));\n\n            if (j == 0) {\n                grid_cell_size[igcs] = area;\n                igcs += 1;\n            }\n\n            grid_cell_size[igcs] = area; grid_cell_size[igcs + 1] = area;\n            igcs += 2;\n\n            if (j == field_nj - 2) {\n                grid_cell_size[igcs] = area; grid_cell_size[igcs + 1] = area; \n                grid_cell_size[igcs + 2] = area;\n                igcs += 3;\n            }\n        }\n    }\n\n    return {'vertices': verts, 'tex_coords': tex_coords, 'grid_cell_size': grid_cell_size};\n}\n\n/*\nfunction makePolylinesMiter(lines) {\n    const n_points_per_vert = Object.fromEntries(Object.entries(lines[0]).map(([k, v]) => {\n        let n_verts;\n        if (v.length === undefined) {\n            n_verts = 1;\n        }\n        else {\n            n_verts = k == 'verts' ? v[0].length : v.length;\n        }\n        return [k, n_verts];\n    }));\n    n_points_per_vert['extrusion'] = 2;\n\n    const n_verts = lines.map(l => l['verts'].length).reduce((a, b) => a + b);\n    const ary_lens = Object.fromEntries(Object.entries(n_points_per_vert).map(([k, nppv]) => [k, (n_verts * 2 + lines.length * 2) * nppv]));\n\n    let ret = Object.fromEntries(Object.entries(ary_lens).map(([k, v]) => [k, new Float32Array(v)]));\n\n    let ilns = Object.fromEntries(Object.keys(ary_lens).map(k => [k, 0]));\n\n    const is_cw_winding = (pt_prev, pt_this, pt_next) => {\n        const winding = (pt_this[0] - pt_prev[0]) * (pt_this[1] + pt_prev[1]) \n                      + (pt_next[0] - pt_this[0]) * (pt_next[1] + pt_this[1]) \n                      + (pt_prev[0] - pt_next[0]) * (pt_prev[1] + pt_next[1]);\n\n        return winding > 0;\n    }\n\n    const calculate_extrusion = (pt_prev, pt_this, pt_next) => {\n        let line_vec_x_prev, line_vec_y_prev, line_vec_mag_prev, \n            line_vec_x_next, line_vec_y_next, line_vec_mag_next;\n        let ext_x, ext_y;\n\n        if (pt_prev !== null) {\n            line_vec_x_prev = pt_this[0] - pt_prev[0];\n            line_vec_y_prev = pt_this[1] - pt_prev[1];\n            line_vec_mag_prev = Math.hypot(line_vec_x_prev, line_vec_y_prev);\n            line_vec_x_prev /= line_vec_mag_prev;\n            line_vec_y_prev /= line_vec_mag_prev;\n        }\n\n        if (pt_next !== null) {\n            line_vec_x_next = pt_next[0] - pt_this[0];\n            line_vec_y_next = pt_next[1] - pt_this[1];\n            line_vec_mag_next = Math.hypot(line_vec_x_next, line_vec_y_next);\n            line_vec_x_next /= line_vec_mag_next;\n            line_vec_y_next /= line_vec_mag_next;\n        }\n\n        if (pt_prev === null) {\n            // First point in the line gets just the normal for the first segment\n            ext_x = line_vec_y_next; ext_y = -line_vec_x_next;\n        }\n        else if (pt_this === null) {\n            // Last point in the line gets just the normal for the last segment\n            ext_x = line_vec_y_prev; ext_y = -line_vec_x_prev;\n        }\n        else {\n            // Miter join: compute the extrusion vector halfway between the next and previous normal\n            const dot = line_vec_x_prev * line_vec_x_next + line_vec_y_prev * line_vec_y_next;\n            const ext_fac = Math.sqrt((1 - dot) / (1 + dot));\n            const sign = is_cw_winding(pt_prev, pt_this, pt_this) ? -1 : 1;\n            ext_x = line_vec_y_prev                  + sign * line_vec_x_prev * ext_fac;\n            ext_y = sign * line_vec_y_prev * ext_fac - line_vec_x_prev;\n        }\n\n        return [ext_x, ext_y];\n    }\n\n    lines.forEach(line => {\n        const verts = line['verts'];\n        let ext_x, ext_y;\n\n        let ivt = 0;\n        ret['verts'][ilns['verts']] = verts[ivt][0]; ret['verts'][ilns['verts'] + 1] = verts[ivt][1];\n\n        [ext_x, ext_y] = calculate_extrusion(null, verts[ivt], verts[ivt + 1]);\n        ret['extrusion'][ilns['extrusion']] = ext_x; ret['extrusion'][ilns['extrusion'] + 1] = ext_y;\n\n        for (ivt = 0; ivt < verts.length; ivt++) {\n            const ary_ivt = ilns['verts'] + 2 * (2 * ivt + 1);\n            ret['verts'][ary_ivt + 0] = verts[ivt][0]; ret['verts'][ary_ivt + 1] = verts[ivt][1];\n            ret['verts'][ary_ivt + 2] = verts[ivt][0]; ret['verts'][ary_ivt + 3] = verts[ivt][1];\n\n            if (ivt == 0) {\n                [ext_x, ext_y] = calculate_extrusion(null, verts[ivt], verts[ivt + 1]);\n            }\n            else if (ivt == verts.length - 1) {\n                [ext_x, ext_y] = calculate_extrusion(verts[ivt - 1], verts[ivt], null);\n            }\n            else {\n                [ext_x, ext_y] = calculate_extrusion(verts[ivt - 1], verts[ivt], verts[ivt + 1]);\n            }\n\n            ret['extrusion'][ary_ivt + 0] =  ext_x; ret['extrusion'][ary_ivt + 1] =  ext_y;\n            ret['extrusion'][ary_ivt + 2] = -ext_x; ret['extrusion'][ary_ivt + 3] = -ext_y;\n        }\n\n        ivt = verts.length - 1;\n        ret['verts'][ilns['verts'] + 2 * (2 * ivt + 1) + 4] = verts[ivt][0]; \n        ret['verts'][ilns['verts'] + 2 * (2 * ivt + 1) + 5] = verts[ivt][1];\n        \n        [ext_x, ext_y] = calculate_extrusion(verts[ivt - 1], verts[ivt], null);\n\n        ret['extrusion'][ilns['extrusion'] + 2 * (2 * ivt + 1) + 4] = -ext_x; \n        ret['extrusion'][ilns['extrusion'] + 2 * (2 * ivt + 1) + 5] = -ext_y;\n\n        for (let key in ret) {\n            if (key == 'verts' || key == 'extrusion') continue;\n\n            for (ivt = 0; ivt < (verts.length * 2 + 2) * n_points_per_vert[key]; ivt += n_points_per_vert[key]) {\n                if (line[key].length !== undefined) {\n                    line[key].forEach((cd, icd) => {\n                        ret[key][ilns[key] + ivt + icd] = cd;\n                    })\n                }\n                else {\n                    ret[key][ilns[key] + ivt] = line[key];\n                }\n            }\n        }\n\n        Object.keys(ilns).forEach(k => {\n            ilns[k] += (verts.length * 2 + 2) * n_points_per_vert[k];\n        })\n    })\n\n    return ret;\n}\n*/\n\nfunction makePolylines(lines: LineData[]) : Polyline {\n    if (lines.length == 0) {\n        return {vertices: new Float32Array([]), extrusion: new Float32Array([])};\n    }\n\n    const n_points_per_vert = Object.fromEntries(Object.entries(lines[0]).map(([k, v]) => {\n        let n_verts: number;\n        if (typeof v === 'number') {\n            n_verts = 1;\n        }\n        else if (typeof v[0] === 'number') {\n            n_verts = 1;\n        }\n        else {\n            n_verts = v[0].length;\n        }\n        return [k, n_verts];\n    }));\n    n_points_per_vert['extrusion'] = 2;\n    n_points_per_vert['vertices'] += 1;\n\n    const n_verts = lines.map(l => l.vertices.length).reduce((a, b) => a + b);\n    const n_out_verts = n_verts * 4 - lines.length * 2;\n    const ary_lens = Object.fromEntries(Object.entries(n_points_per_vert).map(([k, nppv]) => [k, n_out_verts * nppv]));\n\n    let ret: Polyline = {\n        vertices: new Float32Array(ary_lens['vertices']),\n        extrusion: new Float32Array(ary_lens['extrusion']),\n    }\n\n    if ('offsets' in lines[0]) {\n        ret.offsets = new Float32Array(ary_lens['offsets']);\n    }\n\n    if ('data' in lines[0]) {\n        ret.data = new Float32Array(ary_lens['data']);\n    }\n\n    if ('zoom' in lines[0]) {\n        ret.zoom = new Float32Array(ary_lens['zoom']);\n    }\n\n    let ilns = Object.fromEntries(Object.keys(ary_lens).map(k => [k, 0]));\n\n    const compute_normal_vec = (pt1: [number, number], pt2: [number, number], flip_y_coord: boolean) => {\n        const line_vec_x = pt2[0] - pt1[0];\n        const line_vec_y = pt2[1] - pt1[1];\n        const line_vec_mag = Math.hypot(line_vec_x, line_vec_y);\n\n        const ext_x = line_vec_y / line_vec_mag;\n        const ext_y = -line_vec_x / line_vec_mag;\n\n        return [ext_x, flip_y_coord ? -ext_y : ext_y];\n    }\n\n    lines.forEach(line => {\n        const verts = line.vertices.map(v => {\n            const v_ll = new LngLat(...v).toMercatorCoord();\n            return [v_ll.x, v_ll.y] as [number, number];\n        });\n\n        const has_offsets = line.offsets !== undefined;\n        const extrusion_verts = line.offsets !== undefined ? line.offsets : verts;\n\n        let pt_prev: [number, number], pt_this = verts[0], pt_next = verts[1];\n        let ept_prev: [number, number], ept_this = extrusion_verts[0], ept_next = extrusion_verts[1];\n        let len_prev: number, len_this = 0.0001;\n        let [ext_x, ext_y] = compute_normal_vec(ept_this, ept_next, !has_offsets);\n\n        ret.vertices[ilns.vertices++] = pt_this[0]; ret.vertices[ilns.vertices++] = pt_this[1]; ret.vertices[ilns.vertices++] = len_this;\n        ret.extrusion[ilns.extrusion++] = ext_x; ret.extrusion[ilns.extrusion++] = ext_y;\n\n        for (let ivt = 1; ivt < verts.length; ivt++) {\n            pt_this = verts[ivt]; pt_prev = verts[ivt - 1];\n            ept_this = extrusion_verts[ivt]; ept_prev = extrusion_verts[ivt - 1];\n\n            [ext_x, ext_y] = compute_normal_vec(ept_prev, ept_this, !has_offsets);\n            len_prev = len_this; len_this += Math.hypot(verts[ivt - 1][0] - verts[ivt][0], verts[ivt - 1][1] - verts[ivt][1]);\n\n            ret.vertices[ilns.vertices++] = pt_prev[0]; ret.vertices[ilns.vertices++] = pt_prev[1]; ret.vertices[ilns.vertices++] = -len_prev;\n            ret.vertices[ilns.vertices++] = pt_prev[0]; ret.vertices[ilns.vertices++] = pt_prev[1]; ret.vertices[ilns.vertices++] = len_prev;\n\n            ret.vertices[ilns.vertices++] = pt_this[0]; ret.vertices[ilns.vertices++] = pt_this[1]; ret.vertices[ilns.vertices++] = -len_this;\n            ret.vertices[ilns.vertices++] = pt_this[0]; ret.vertices[ilns.vertices++] = pt_this[1]; ret.vertices[ilns.vertices++] = len_this;\n\n            ret.extrusion[ilns.extrusion++] =  ext_x; ret.extrusion[ilns.extrusion++] =  ext_y;\n            ret.extrusion[ilns.extrusion++] = -ext_x; ret.extrusion[ilns.extrusion++] = -ext_y;\n\n            ret.extrusion[ilns.extrusion++] =  ext_x; ret.extrusion[ilns.extrusion++] =  ext_y;\n            ret.extrusion[ilns.extrusion++] = -ext_x; ret.extrusion[ilns.extrusion++] = -ext_y;\n        }\n\n        ret.vertices[ilns.vertices++] = pt_this[0]; ret.vertices[ilns.vertices++] = pt_this[1]; ret.vertices[ilns.vertices++] = len_this;\n        ret.extrusion[ilns.extrusion++] = -ext_x; ret.extrusion[ilns.extrusion++] = -ext_y;\n\n        if (ret.offsets !== undefined && line.offsets !== undefined) {\n            const offsets = line.offsets;\n            let off_prev: [number, number], off_this = offsets[0];\n\n            ret.offsets[ilns.offsets++] = off_this[0]; ret.offsets[ilns.offsets++] = off_this[1];\n\n            for (let ivt = 1; ivt < offsets.length; ivt++) {\n                off_this = offsets[ivt]; off_prev = offsets[ivt - 1];\n\n                ret.offsets[ilns.offsets++] = off_prev[0]; ret.offsets[ilns.offsets++] = off_prev[1];\n                ret.offsets[ilns.offsets++] = off_prev[0]; ret.offsets[ilns.offsets++] = off_prev[1];\n                ret.offsets[ilns.offsets++] = off_this[0]; ret.offsets[ilns.offsets++] = off_this[1];\n                ret.offsets[ilns.offsets++] = off_this[0]; ret.offsets[ilns.offsets++] = off_this[1];\n            }\n\n            ret.offsets[ilns.offsets++] = off_this[0]; ret.offsets[ilns.offsets++] = off_this[1];\n        }\n\n        if (ret.data !== undefined && line.data !== undefined) {\n            const data = line.data;\n            let data_prev: number, data_this = data[0];\n\n            ret.data[ilns.data++] = data_this;\n            \n            for (let ivt = 1; ivt < data.length; ivt++) {\n                data_this = data[ivt]; data_prev = data[ivt - 1];\n\n                ret.data[ilns.data++] = data_prev;\n                ret.data[ilns.data++] = data_prev;\n                ret.data[ilns.data++] = data_this;\n                ret.data[ilns.data++] = data_this;\n            }\n\n            ret.data[ilns.data++] = data_this;\n        }\n        \n        if (ret.zoom !== undefined && line.zoom !== undefined) {\n            for (let ivt = 0; ivt < verts.length * 4 - 2; ivt++) {\n                ret.zoom[ilns.zoom++] = line['zoom'];\n            }\n        }\n    })\n\n    return ret;\n}\n\nconst ep_interface = {\n    'makeBBElements': makeBBElements, \n    'makeDomainVerticesAndTexCoords': makeDomainVerticesAndTexCoords,\n    'makePolyLines': makePolylines\n}\n\ntype PlotLayerWorker = typeof ep_interface;\n\nComlink.expose(ep_interface);\n\nexport type {PlotLayerWorker}"],"names":["root","factory","exports","module","define","amd","this","getMinZoom","jlat","ilon","thin_fac_base","zoom","thin_fac","proxyMarker","Symbol","createEndpoint","releaseProxy","throwMarker","isObject","val","transferHandlers","Map","canHandle","serialize","obj","port1","port2","MessageChannel","expose","deserialize","port","start","createProxy","target","value","serialized","Error","isError","message","name","stack","Object","assign","ep","self","addEventListener","callback","ev","data","id","type","path","argumentList","map","fromWireValue","returnValue","parent","slice","reduce","prop","rawValue","apply","proxy","transfers","transferCache","set","transfer","undefined","Promise","resolve","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","endpoint","constructor","isMessagePort","close","throwIfProxyReleased","isReleased","isProxyReleased","Proxy","get","_target","requestResponseMessage","p","toString","length","r","bind","_thisArg","rawArgumentList","last","processArguments","construct","processed","v","arr","Array","prototype","concat","WeakMap","handler","serializedValue","msg","fill","Math","floor","random","Number","MAX_SAFE_INTEGER","join","l","lng","lat","isNaN","toMercatorCoord","x","y","sin_lat","sin","PI","log","min","max","fromMercatorCoord","LngLat","lngFromMercatorX","atan","sinh","latFromMercatorY","field_lats","field_lons","field_ni","field_nj","max_zoom","n_density_tiers","log2","n_inaccessible_tiers","trim_inaccessible","pow","field_ni_access","field_nj_access","n_elems_tc","pts","Float32Array","tex_coords","istart_pts","istart_tc","ilat","idx","lon","pt_ll","icrnr","actual_icrnr","texcoord_margin_r","texcoord_margin_s","verts","grid_cell_size","ivert","itexcoord","i","j","pt","pt_ip1","rp1","s","igcs","x_ll","y_ll","x_lr","y_lr","x_ul","y_ul","x_ur","y_ur","area","abs","lines","vertices","extrusion","n_points_per_vert","fromEntries","entries","k","n_out_verts","a","b","ary_lens","nppv","ret","offsets","ilns","keys","compute_normal_vec","pt1","pt2","flip_y_coord","line_vec_x","line_vec_y","line_vec_mag","hypot","ext_y","forEach","line","pt_prev","ept_prev","len_prev","v_ll","has_offsets","extrusion_verts","pt_this","ept_this","ept_next","len_this","ext_x","ivt","off_prev","off_this","data_prev","data_this"],"sourceRoot":""}
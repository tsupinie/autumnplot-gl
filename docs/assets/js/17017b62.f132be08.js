"use strict";(self.webpackChunkautumnplot_gl_docs=self.webpackChunkautumnplot_gl_docs||[]).push([[5413],{8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>l});var a=n(6540);const o={},i=a.createContext(o);function s(e){const t=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(i.Provider,{value:t},e.children)}},9323:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"varying","title":"Varying the Data Plots","description":"In previous examples, we\'ve plotted a static dataset on a map, but in many instances, you want to view a dataset that changes, say over time. In order to switch the data currently plotted, you can call updateField() on the plot component (e.g, ContourFilled, Barbs, etc.) to switch what field is plotted.","source":"@site/docs/varying.md","sourceDirName":".","slug":"/varying","permalink":"/autumnplot-gl/docs/varying","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Advanced Data Plotting","permalink":"/autumnplot-gl/docs/advanced"},"next":{"title":"Color Maps","permalink":"/autumnplot-gl/docs/colormaps"}}');var o=n(4848),i=n(8453);const s={sidebar_position:4},l="Varying the Data Plots",r={},d=[];function c(e){const t={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"varying-the-data-plots",children:"Varying the Data Plots"})}),"\n",(0,o.jsxs)(t.p,{children:["In previous examples, we've plotted a static dataset on a map, but in many instances, you want to view a dataset that changes, say over time. In order to switch the data currently plotted, you can call ",(0,o.jsx)(t.code,{children:"updateField()"})," on the plot component (e.g, ",(0,o.jsx)(t.code,{children:"ContourFilled"}),", ",(0,o.jsx)(t.code,{children:"Barbs"}),", etc.) to switch what field is plotted."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:"// Create the initial field\nconst height_field_f00 = new RawScalarField(grid, height_data_f00);\nconst fills = new Contour(height_data_f00, {interval: 30});\n\n// Update the field plotted\nconst height_field_f01 = new RawScalarField(grid, height_data_f01);\nfills.updateField(height_field_f01);\n"})}),"\n",(0,o.jsxs)(t.p,{children:["One potential issue with this method for contour plots in particular is that the contouring is done when you call ",(0,o.jsx)(t.code,{children:"updateField()"}),". If you have large grids, this can introduce some lag into your application when the user updates the plot time. One way to solve this is to use ",(0,o.jsx)(t.code,{children:"MultiPlotLayer"}),". The main difference between this and using ",(0,o.jsx)(t.code,{children:"updateField()"})," is that ",(0,o.jsx)(t.code,{children:"MultiPlotLayer"})," will put all data for all times onto VRAM at once. In contrast, with ",(0,o.jsx)(t.code,{children:"PlotLayer"})," and ",(0,o.jsx)(t.code,{children:"updateField()"}),", only the data currently plotted are stored on VRAM. For contour plots, this means all the contouring is done up front, so switching fields is fast. However, for large grids, using a ",(0,o.jsx)(t.code,{children:"MultiPlotLayer"})," may take up a large amount of VRAM, so consider mobile devices with limited VRAM when using a ",(0,o.jsx)(t.code,{children:"MultiPlotLayer"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:"// Contour some data\nconst height_contour_f00 = new Contour(height_f00);\nconst height_contour_f01 = new Contour(height_f01);\nconst height_contour_f02 = new Contour(height_f02);\n\n// Create a varying map layer\nconst height_layer_time = new MultiPlotLayer('height-contour-time');\n\n// Add the contoured data to it\nheight_layer_time.addField(height_contour_f00, '20230112_1200');\nheight_layer_time.addField(height_contour_f01, '20230112_1300');\nheight_layer_time.addField(height_contour_f02, '20230112_1400');\n\n// Add to the map like normal\nmap.on('load', () => {\n    map.addLayer(height_layer_time, 'railway_transit_tunnel');\n});\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The second argument to ",(0,o.jsx)(t.code,{children:"addField()"})," is the key to associate with this field. This example uses the absolute time, but you could just as easily use ",(0,o.jsx)(t.code,{children:"'f00'"}),", ",(0,o.jsx)(t.code,{children:"'f01'"}),", etc., or anything else that's relevant as long as it's unique. Now to set the active time (i.e., the time that gets plotted):"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:"// Set the active field in the map layer (the map updates automatically)\nheight_layer.setActiveKey('20230112_1200');\n"})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);